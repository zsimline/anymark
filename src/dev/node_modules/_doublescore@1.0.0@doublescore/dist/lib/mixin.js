'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var clone_1 = __importDefault(require("./clone"));
var types = __importStar(require("./types"));
var mixinDepth = 0;
function mixin() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (args.length < 1) {
        mixinDepth = 0;
        return undefined;
    }
    mixinDepth++;
    if (mixinDepth >= 100) {
        mixinDepth = 0;
        throw new Error('max mixin depth of 100 reached');
    }
    var target = clone_1.default(args[0]); // clone so we don't modify the original
    // handle arbitrary number of mixins. precedence is from last to first item passed in.
    for (var i = 1; i < args.length; i++) {
        var source = args[i];
        // mixin the source differently depending on what is in the destination
        switch (types.getType(target)) {
            case 'object':
            case 'array':
            case 'function':
                // mixin in the source differently depending on its type
                switch (types.getType(source)) {
                    case 'array':
                    case 'object':
                    case 'function':
                        // we don't care what descendant of object the source is
                        for (var field in source) {
                            // don't mixin parent fields
                            if (source.hasOwnProperty(field)) {
                                // if the target is an array, only take fields that are integers
                                if (types.isArray(target)) {
                                    var fieldFloat = parseFloat(field);
                                    // the field started with a number, or no number at all, then had non-numeric characters
                                    if (isNaN(fieldFloat) || fieldFloat.toString().length !== field.length || types.getType(fieldFloat) !== 'integer') {
                                        continue;
                                    }
                                }
                                // recurse mixin differently depending on what the target value is
                                switch (types.getType(target[field])) {
                                    // for any non-objects, do this
                                    case 'undefined':
                                    case 'null':
                                        switch (types.getType(source[field])) {
                                            case 'undefined':
                                                // NO-OP undefined doesn't override anything
                                                break;
                                            case 'null':
                                                // tslint:disable-next-line:no-null-keyword
                                                target[field] = null;
                                                break;
                                            default:
                                                target[field] = clone_1.default(source[field]);
                                                break;
                                        }
                                        break;
                                    // if the target is already an object, we can mixin on it
                                    default:
                                        target[field] = mixin(target[field], source[field]);
                                        break;
                                }
                            }
                        }
                        break;
                    default:
                        // NO-OP, primitives can't mixin to objects, arrays and functions
                        break;
                }
                break;
            default:
                // mixin in the source differently depending on its type
                switch (types.getType(source)) {
                    // arrays and objects just replace primitives
                    case 'array':
                    case 'object':
                        // override primitives by just passing through a clone of parent
                        target = clone_1.default(source);
                        break;
                    default:
                        // target is a primitive and can't be null or undefined here, and all other primitives have equal precedence, so just pass through
                        target = source;
                        break;
                }
                break;
        }
    }
    mixinDepth--;
    return target;
}
exports.default = mixin;
//# sourceMappingURL=mixin.js.map